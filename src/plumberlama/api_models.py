# generated by datamodel-codegen:
#   filename:  openapi.json
#   timestamp: 2025-10-14T11:42:59+00:00

from __future__ import annotations

from enum import Enum
from typing import Optional, Union

from pydantic import AwareDatetime, BaseModel, EmailStr, Field, RootModel


class Type(Enum):
    category = "category"
    user = "user"
    team = "team"
    all = "all"


class Tag(BaseModel):
    id: int = Field(..., description="Identifier of the tag", ge=1)
    name: str = Field(..., description="Name of the tag")
    type: Type = Field(..., description="The tags type")
    parentId: Optional[int] = Field(
        None, description="Identifier of the parent tag", ge=1
    )


class Access(BaseModel):
    isPublic: bool
    passwords: Optional[list[str]] = Field(
        None, description="List of passwords that grant access to the poll"
    )
    isCookieLocksEnabled: bool
    isIpLocksEnabled: bool
    isCorrectionModeEnabled: bool
    iframeAllowedFrom: Optional[list[str]] = Field(
        None, description="List of urls to allow iframes from"
    )
    ipWhitelist: Optional[list[str]] = Field(
        None, description="A whitelist of allowed IPs to access the poll"
    )
    ipBlacklist: Optional[list[str]] = Field(
        None, description="A blacklist of forbidden IPs to access the poll"
    )


class Privacy(BaseModel):
    isAnonym: bool = Field(
        ..., description="Specifies whether or not the poll is an anonymous survey"
    )
    isDeviceDetectionEnabled: bool = Field(
        ...,
        description="Specifies if lamapoll will collect information about the devices used by respondents",
    )
    isRefererDetectionEnabled: bool = Field(
        ...,
        description="Specifies if lamapoll will collect information about how respondents visited the poll (e.g. using a link from social media)",
    )


class Settings(BaseModel):
    nextStartAt: Optional[AwareDatetime] = Field(
        None, description="Date time of the next start of the poll"
    )
    nextStopAt: Optional[AwareDatetime] = Field(
        None, description="Date time of the the next stop of the poll"
    )
    access: Optional[Access] = Field(
        None, description="Access settings of the poll", title="Access Settings"
    )
    privacy: Optional[Privacy] = Field(
        None, description="Privacy settings of the poll", title="Privacy Settings"
    )


class State(BaseModel):
    responsesCount: Optional[float] = Field(
        None, description="The number of current responses of a poll"
    )
    isRunning: Optional[bool] = Field(
        None, description="Whether or not the poll is currently running"
    )
    lastActivityAt: Optional[AwareDatetime] = Field(
        None, description="Date time of the last activity"
    )


class Poll(BaseModel):
    id: int = Field(..., description="Identifier of the poll", ge=1)
    name: str = Field(..., description="Name of the poll")
    title: Optional[str] = Field(None, description="The title of the poll")
    description: Optional[str] = Field(
        None, description="A description text of the poll"
    )
    notice: Optional[str] = Field(None, description="A note attached to the poll")
    url: str = Field(..., description="The url to visit the poll")
    pagesCount: int = Field(..., description="The number of pages of the poll")
    createdAt: AwareDatetime = Field(
        ..., description="Date time when the poll was created"
    )
    modifiedAt: AwareDatetime = Field(
        ..., description="Date time of the last modification to the poll"
    )
    closedAt: Optional[AwareDatetime] = Field(
        None, description="Date time when the poll got closed"
    )
    startedAt: Optional[AwareDatetime] = Field(
        None, description="Date time when the poll got open"
    )
    tags: Optional[list[Tag]] = None
    settings: Settings = Field(..., description="Settings of a poll", title="Settings")
    state: State


class ResponseStatus(Enum):
    not_started = "not_started"
    started = "started"
    completed = "completed"
    finished = "finished"


class InviteStatus(Enum):
    not_sent = "not_sent"
    sent = "sent"
    failed = "failed"


class RemindStatus(Enum):
    not_sent = "not_sent"
    sent = "sent"
    failed = "failed"


class FollowupStatus(Enum):
    not_sent = "not_sent"
    sent = "sent"
    failed = "failed"


class Respondent(BaseModel):
    name: str = Field(..., description="The name of the respondent")
    email: EmailStr = Field(..., description="The E-Mail address of the respondent")
    attributes: Optional[list[str]] = Field(
        None, description="Attributes associated with a respondent"
    )
    id: int = Field(..., description="The identifier of the respondent", ge=1)
    pollId: int = Field(..., description="The identifier of the poll", ge=1)
    responseStatus: ResponseStatus = Field(
        ..., description="The status of the respondents response"
    )
    inviteStatus: InviteStatus = Field(..., description="The state of the invitation")
    remindStatus: Optional[RemindStatus] = Field(
        None, description="The state of a reminder mailing job"
    )
    followupStatus: Optional[FollowupStatus] = Field(
        None, description="The state of a followup mailing job"
    )
    accessKey: Optional[str] = Field(
        None,
        description="The access key for the respondent if they participated in a non-anonymous poll\n",
    )
    emailOptOut: Optional[bool] = Field(
        False, description="If the respondent has opted out of receiving emails"
    )
    createdAt: AwareDatetime = Field(
        ..., description="The date and time when the respondent was created"
    )
    modifiedAt: AwareDatetime = Field(
        ..., description="The date and time when the respondent was last modified"
    )


class Status(Enum):
    pending = "pending"
    running = "running"
    finished = "finished"
    failed = "failed"


class Progress(BaseModel):
    total: int = Field(..., description="The total number of respondents to import")
    imported: int = Field(..., description="The number of respondents already imported")
    failed: int = Field(..., description="The number of entries that failed to import")
    skipped: int = Field(..., description="The number of entries that were skipped")


class RespondentsImportTask(BaseModel):
    id: int = Field(..., description="The identifier of the import task", ge=1)
    pollId: int = Field(..., description="The identifier of the poll", ge=1)
    status: Status = Field(..., description="The status of the import task")
    createdAt: AwareDatetime = Field(
        ..., description="The date and time when the import task was created"
    )
    startedAt: Optional[AwareDatetime] = Field(
        None, description="The date and time when the import task was started"
    )
    finishedAt: Optional[AwareDatetime] = Field(
        None, description="The date and time when the import task was finished"
    )
    progress: Progress = Field(
        ..., description="Progress information about the import task"
    )


class Mode(Enum):
    include = "include"
    exclude = "exclude"
    select = "select"
    omit = "omit"


class Attributes(BaseModel):
    mode: Mode = Field(
        ...,
        description="Sets the mode for importing attributes.\n\n| Mode    | Description |\n| ------- | ----------- |\n| *include* | Import all attributes contained in the CSV file |\n| *exclude* | Do not import any attribute contained in the CSV file |\n| *select*  | Import only the attributes specified in the `columns` property |\n| *omit*    | Import all attributes except the ones specified in the `columns` property |\n",
    )
    columns: Optional[list[int]] = Field(
        None,
        description='List of attributes to include/exclude from the import.\n> Only used (and required) if `mode` is set to *"select"* or *"omit"*.\n',
    )


class CreateRespondentsImportTask(BaseModel):
    file: bytes = Field(
        ..., description="CSV file containing the respondents to import"
    )
    delimiter: Optional[str] = Field(
        None,
        description="Delimiter used in the CSV file. If not set, it will be auto-detected.",
    )
    enclosure: Optional[str] = Field('"', description="Enclosure used in the CSV file")
    nameColumn: Optional[int] = Field(
        None,
        description="Index of the column containing the name (0-based) Specify the column containing the name of the respondent. </br> <details>\n  <summary>Note</summary>\n  If omitted, we will look for a column with a header like 'Name' to set a respondents name. \n  If we could not find one, the name will be unset.\n</details>\n",
    )
    emailColumn: Optional[int] = Field(
        None,
        description="Index of the column containing the email (0-based) Specify the column containing the email of the respondent if there is no header titled 'E-Mail' or 'email'.\n",
    )
    attributes: Optional[Attributes] = Field(
        None,
        description="Specifies how attributes should be imported from the CSV file",
    )
    uniqueEmails: Optional[bool] = Field(
        False,
        description="Whether to enforce unique email addresses for the respondents of the poll.\n> If set to `true`, entries in the CSV will be omitted if the email address is already associated with a \nrespondent of the poll. Only the first occurrence of a duplicate email address in the CSV will be imported.\nAny omitted entries will be counted as failed imports.\n",
    )


class Type1(Enum):
    reminder = "reminder"
    followup = "followup"
    invite = "invite"


class Attachment(BaseModel):
    id: Optional[int] = Field(None, description="The identifier of the attachment")
    name: Optional[str] = Field(None, description="The name of the attachment")
    size: Optional[int] = Field(None, description="The attachements file size in bytes")
    ext: Optional[str] = Field(None, description="The file extension", examples=["pdf"])
    url: Optional[str] = Field(
        None, description="The url that can be used to download the attachment."
    )


class EMailTemplate(BaseModel):
    id: float = Field(..., description="The identifier of the template", ge=1.0)
    type: Type1 = Field(..., description="The type of the template")
    name: str = Field(..., description="The name of the template")
    subject: str = Field(..., description="The emails subject")
    text: str = Field(..., description="The text of the email")
    default: Optional[bool] = Field(
        None, description="Whether this is the default template"
    )
    attachments: Optional[list[Attachment]] = Field(
        None, description="E-Mail attachements"
    )
    createdAt: Optional[AwareDatetime] = Field(
        None, description="Date time when the template was created"
    )
    modifiedAt: Optional[AwareDatetime] = Field(
        None, description="Date time of the last modification of the template"
    )


class Status1(Enum):
    waiting = "waiting"
    in_progress = "in_progress"
    done = "done"
    failed = "failed"
    cancelled = "cancelled"


class Receivers(Enum):
    all = "all"
    not_invited = "not_invited"
    invited = "invited"
    started = "started"
    not_started = "not_started"
    finished = "finished"
    not_finished = "not_finished"
    started_not_finished = "started_not_finished"
    not_started_all = "not_started_all"
    finished_all = "finished_all"
    not_finished_all = "not_finished_all"
    started_not_finished_all = "started_not_finished_all"


class Mailing1(BaseModel):
    id: int = Field(..., description="The identifier of the mailing job", ge=1)
    prevId: Optional[int] = Field(
        None,
        description="The identifier of the preceeding mailing job (e.g. 'invite' mailing job for 'reminder' emails). Omitted then there is none",
        ge=1,
    )
    pollId: int = Field(
        ..., description="The identifier of the poll this mailing job belongs to", ge=1
    )
    templateId: int = Field(
        ..., description="The identifier of the template to use for the E-Mail", ge=1
    )
    type: Type1 = Field(..., description="The type of the template")
    senderId: Optional[int] = Field(
        None,
        description="The identifier of the sender of the email. Omitted if this is the default value.",
        ge=1,
    )
    numOfReceivers: int = Field(
        ..., description="The count of respondents to receive the mailing job", ge=0
    )
    executeAt: AwareDatetime = Field(
        ..., description="Date time to send the mailing job"
    )
    status: Status1 = Field(..., description="The status of the mailing job")
    mailServerId: Optional[int] = Field(
        None,
        description="The identifier of the mail server to use for the mailing job. Omitted if no custom mailserver is specified",
        ge=1,
    )
    finishedAt: Optional[AwareDatetime] = Field(
        None,
        description="Date time when the mailing job has finished. Omitted if it has not.",
    )
    receivers: Receivers = Field(..., description="Enum value that selects respondents")
    attributes: Optional[Union[dict[str, list[str]], list[list[str]]]] = Field(
        None,
        description="A list of attributes a respondent should have to receive the mailing",
        title="Selected Attributes",
    )


class RespondentId(RootModel[int]):
    root: int = Field(..., description="The identifier of the respondent", ge=1)


class Mailing2(BaseModel):
    id: int = Field(..., description="The identifier of the mailing job", ge=1)
    prevId: Optional[int] = Field(
        None,
        description="The identifier of the preceeding mailing job (e.g. 'invite' mailing job for 'reminder' emails). Omitted then there is none",
        ge=1,
    )
    pollId: int = Field(
        ..., description="The identifier of the poll this mailing job belongs to", ge=1
    )
    templateId: int = Field(
        ..., description="The identifier of the template to use for the E-Mail", ge=1
    )
    type: Type1 = Field(..., description="The type of the template")
    senderId: Optional[int] = Field(
        None,
        description="The identifier of the sender of the email. Omitted if this is the default value.",
        ge=1,
    )
    numOfReceivers: int = Field(
        ..., description="The count of respondents to receive the mailing job", ge=0
    )
    executeAt: AwareDatetime = Field(
        ..., description="Date time to send the mailing job"
    )
    status: Status1 = Field(..., description="The status of the mailing job")
    mailServerId: Optional[int] = Field(
        None,
        description="The identifier of the mail server to use for the mailing job. Omitted if no custom mailserver is specified",
        ge=1,
    )
    finishedAt: Optional[AwareDatetime] = Field(
        None,
        description="Date time when the mailing job has finished. Omitted if it has not.",
    )
    respondentIds: list[RespondentId] = Field(
        ...,
        description="List of respondent IDs of those who will receive the mailing job",
    )


class Mailing(RootModel[Union[Mailing1, Mailing2]]):
    root: Union[Mailing1, Mailing2] = Field(..., title="Mailing Job")


class Type4(Enum):
    MATRIX = "MATRIX"
    CHOICE = "CHOICE"
    SCALE = "SCALE"
    INPUT = "INPUT"
    RANKING = "RANKING"


class InputType(Enum):
    SINGLELINE = "SINGLELINE"
    MULTILINE = "MULTILINE"
    INTEGER = "INTEGER"
    FLOAT = "FLOAT"
    DATE = "DATE"
    TIME = "TIME"
    CAPTCHA = "CAPTCHA"
    UPLOAD = "UPLOAD"


class Item(BaseModel):
    id: Optional[str] = Field(None, description="Unique identifier of the item")
    name: Optional[dict[str, str]] = Field(None, description="The item name.")


class Group(BaseModel):
    name: dict[str, str]
    inputType: Optional[InputType] = Field(
        None,
        description="The data type for the input field if this group originated from an input field question.",
    )
    labels: list[dict[str, str]]
    range: Optional[list[float]] = Field(
        None,
        description="Range information for scale questions as [min, max, stepSize]",
        max_length=3,
        min_length=3,
    )
    varnames: list[str]
    codes: list[str]
    items: list[Item]


class Questions(BaseModel):
    id: int = Field(..., description="Identifier of the question", ge=1)
    pollId: int = Field(..., description="Identifier of the poll", ge=1)
    pageId: int = Field(..., description="Identifier of the page", ge=1)
    position: Optional[int] = Field(
        None, description="Position of the question within the page", ge=1
    )
    question: Optional[dict[str, str]] = Field(
        None,
        description="The question title in all languages configured for this poll.",
    )
    description: Optional[dict[str, str]] = Field(
        None,
        description="The question description in all languages configured for this poll.",
    )
    anonym: Optional[bool] = Field(
        False,
        description="Should the question collect personal data and be evaluated separately.",
    )
    mandatory: Optional[bool] = Field(
        False,
        description="Is the question mandatory in order to proceed to the next page.",
    )
    type: Type4
    groups: Optional[list[Group]] = None


class Summary(BaseModel):
    numResponses: Optional[int] = Field(None, ge=0)
    numReturns: Optional[int] = Field(None, ge=0)
    numAnswers: Optional[int] = Field(None, ge=0)
    numVisitors: Optional[int] = Field(None, ge=0)


class Summary1(BaseModel):
    responses: Optional[int] = Field(None, description="Number of participants", ge=0)
    seen: Optional[int] = Field(
        None, description="Number of participants who saw the question", ge=0
    )
    answered: Optional[int] = Field(
        None, description="Number of participants who answered the question", ge=0
    )
    ignored: Optional[int] = Field(
        None, description="Number of participants who ignored the question", ge=0
    )
    noAnswer: Optional[int] = Field(
        None, description="Number of participants who did not answer the question", ge=0
    )
    answers: Optional[int] = Field(None, description="Total number of answers", ge=0)


class Ab(RootModel[int]):
    root: int = Field(..., ge=0)


class RelItem(RootModel[float]):
    root: float = Field(..., ge=0.0, le=100.0)


class RelToAnswer(RootModel[float]):
    root: float = Field(..., ge=0.0, le=100.0)


class Freq(BaseModel):
    abs: Optional[list[Ab]] = Field(None, description="Absolute count of each value")
    rel: Optional[list[RelItem]] = Field(
        None,
        description="Relative count of each value compared to the total number of answers for a question",
    )
    relToAnswers: Optional[list[RelToAnswer]] = Field(
        None,
        description="Relative count of each value compared to the total number of participants of a question",
    )


class Values(BaseModel):
    sum: Optional[float] = None
    mean: Optional[float] = None
    med: Optional[float] = Field(None, description="Median")
    var: Optional[float] = Field(None, description="Variance")
    dev: Optional[float] = Field(None, description="Standard deviation")
    min: Optional[float] = None
    max: Optional[float] = None


class Points(BaseModel):
    sum: Optional[float] = None
    mean: Optional[float] = None
    med: Optional[float] = Field(None, description="Median")
    var: Optional[float] = Field(None, description="Variance")
    dev: Optional[float] = Field(None, description="Standard deviation")
    min: Optional[float] = None
    max: Optional[float] = None


class Stats(BaseModel):
    values: Optional[Values] = None
    points: Optional[Points] = None


class Item1(BaseModel):
    id: Optional[str] = Field(None, description="Unique identifier of the item")
    name: Optional[str] = None
    freq: Optional[Freq] = Field(
        None,
        description="Frquency of each value in the values property of this group in absolute and relative terms",
    )
    stats: Optional[Stats] = None
    summary: Optional[Summary1] = None


class Group1(BaseModel):
    name: Optional[str] = Field(
        None,
        description="Name of the group. For matrix questions this field is the block text for a group of columns",
    )
    labels: Optional[list[str]] = Field(None, description="Text labelling for values")
    range: Optional[list[float]] = Field(
        None, description="Min/max values for scales, empty otherwise"
    )
    values: Optional[list[float]] = Field(
        None, description="User defined values. e.g for scales (1-5)"
    )
    weights: Optional[list[float]] = Field(
        None, description="User defined weights for the values"
    )
    points: Optional[list[float]] = Field(
        None, description="User defiend points for the values"
    )
    varnames: Optional[list[str]] = Field(
        None, description="The stored encodings of the question group or block."
    )
    codes: Optional[list[str]] = Field(
        None, description="The stored encodings of the question group or block options."
    )
    items: Optional[list[Item1]] = Field(
        None, description="Holds frequencies and statistics for each item"
    )


class Result(BaseModel):
    questionId: int = Field(..., description="Identifier of the question", ge=1)
    question: str = Field(..., description="Question title")
    description: Optional[str] = Field(None, description="Question description")
    summary: Summary1 = Field(
        ...,
        description="How many respondents answered, ignored, or did not answer the question",
    )
    groups: list[Group1]


class PollResults(BaseModel):
    name: str = Field(..., description="Name of the poll")
    summary: Summary
    results: list[Result]


class Freq1(BaseModel):
    abs: Optional[list[Ab]] = Field(None, description="Absolute count of each value")
    rel: Optional[list[RelItem]] = Field(
        None,
        description="Relative count of each value compared to the total number of answers for a question",
    )
    relToAnswers: Optional[list[RelToAnswer]] = Field(
        None,
        description="Relative count of each value compared to the total number of participants of a question",
    )


class Stats1(BaseModel):
    values: Optional[Values] = None
    points: Optional[Points] = None


class Item2(BaseModel):
    id: Optional[str] = Field(None, description="Unique identifier of the item")
    name: Optional[str] = None
    freq: Optional[Freq1] = Field(
        None,
        description="Frquency of each value in the values property of this group in absolute and relative terms",
    )
    stats: Optional[Stats1] = None
    summary: Optional[Summary1] = None


class Group2(BaseModel):
    name: Optional[str] = Field(
        None,
        description="Name of the group. For matrix questions this field is the block text for a group of columns",
    )
    labels: Optional[list[str]] = Field(None, description="Text labelling for values")
    range: Optional[list[float]] = Field(
        None, description="Min/max values for scales, empty otherwise"
    )
    values: Optional[list[float]] = Field(
        None, description="User defined values. e.g for scales (1-5)"
    )
    weights: Optional[list[float]] = Field(
        None, description="User defined weights for the values"
    )
    points: Optional[list[float]] = Field(
        None, description="User defiend points for the values"
    )
    varnames: Optional[list[str]] = Field(
        None, description="The stored encodings of the question group or block."
    )
    codes: Optional[list[str]] = Field(
        None, description="The stored encodings of the question group or block options."
    )
    items: Optional[list[Item2]] = Field(
        None, description="Holds frequencies and statistics for each item"
    )


class QuestionResults(BaseModel):
    questionId: int = Field(..., description="Identifier of the question", ge=1)
    question: str = Field(..., description="Question title")
    description: Optional[str] = Field(None, description="Question description")
    summary: Summary1 = Field(
        ...,
        description="How many respondents answered, ignored, or did not answer the question",
    )
    groups: list[Group2]


class Type5(Enum):
    poll_report = "poll_report"


class Type6(Enum):
    response_notification = "response_notification"


class ReportJob(BaseModel):
    id: Optional[int] = Field(None, description="The ID of the report job", ge=1)
    pollId: Optional[int] = Field(None, description="The ID of the poll", ge=1)
    type: Optional[Union[Type5, Type6]] = Field(
        None,
        description="A poll report or a response notification report",
        title="Report type",
    )
    interval: Optional[int] = Field(
        1,
        description="The number of days or responses after which a report or notification should be mailed to the user\n",
        ge=1,
        title="Report interval",
    )
    lastReport: Optional[AwareDatetime] = Field(
        None, description="The date of the last report"
    )
    lastNumResponses: Optional[int] = Field(
        None, description="The number of responses in the last report", ge=0
    )


class Participants(BaseModel):
    started: Optional[int] = Field(
        None, description="Total number of participants that started the poll", ge=0
    )
    completed: Optional[int] = Field(
        None, description="Total number of participants that completed the poll", ge=0
    )
    finished: Optional[int] = Field(
        None, description="Total number of participants that finished the poll", ge=0
    )
    visited: Optional[int] = Field(
        None,
        description="Total number of participants that opened but did not start the poll",
        ge=0,
    )


class Period(BaseModel):
    from_: Optional[AwareDatetime] = Field(
        None, alias="from", description="Report start date"
    )
    to: Optional[AwareDatetime] = Field(None, description="Report end date")
    participants: Optional[Participants] = Field(
        None, description="Participation statistics for the reporting period"
    )


class Meta(BaseModel):
    isFinished: Optional[bool] = Field(None, description="Whether the poll is finished")
    isPublic: Optional[bool] = Field(None, description="Whether the poll is public")
    isAnonymous: Optional[bool] = Field(
        None, description="Whether the poll is anonymous"
    )
    openDate: Optional[AwareDatetime] = Field(
        None, description="The date when the poll was opened"
    )
    closeDate: Optional[AwareDatetime] = Field(
        None, description="The closing date of the poll"
    )


class AddressBook(BaseModel):
    started: Optional[int] = Field(
        None, description="Total number of participants that started the poll", ge=0
    )
    completed: Optional[int] = Field(
        None, description="Total number of participants that completed the poll", ge=0
    )
    finished: Optional[int] = Field(
        None, description="Total number of participants that finished the poll", ge=0
    )


class AccessKeys(BaseModel):
    started: Optional[int] = Field(
        None, description="Total number of participants that started the poll", ge=0
    )
    completed: Optional[int] = Field(
        None, description="Total number of participants that completed the poll", ge=0
    )
    finished: Optional[int] = Field(
        None, description="Total number of participants that finished the poll", ge=0
    )


class Public(BaseModel):
    started: Optional[int] = Field(
        None, description="Total number of participants that started the poll", ge=0
    )
    completed: Optional[int] = Field(
        None, description="Total number of participants that completed the poll", ge=0
    )
    finished: Optional[int] = Field(
        None, description="Total number of participants that finished the poll", ge=0
    )


class Participants1(BaseModel):
    started: Optional[int] = Field(
        None, description="Total number of participants that started the poll", ge=0
    )
    completed: Optional[int] = Field(
        None, description="Total number of participants that completed the poll", ge=0
    )
    finished: Optional[int] = Field(
        None, description="Total number of participants that finished the poll", ge=0
    )
    total: Optional[int] = Field(
        None, description="Total number of participants that opened the poll", ge=0
    )
    visited: Optional[int] = Field(
        None,
        description="Total number of participants that opened but did not start the poll",
        ge=0,
    )
    addressBook: Optional[AddressBook] = None
    accessKeys: Optional[AccessKeys] = None
    public: Optional[Public] = None


class PollReport(BaseModel):
    period: Optional[Period] = Field(None, description="The reporting period")
    meta: Optional[Meta] = Field(None, description="Meta information about the poll")
    participants: Optional[Participants1] = None


class Participants2(BaseModel):
    visitors: Optional[int] = Field(
        None,
        description="Participants that have seen a page but not answered any questions or jumped to another page",
    )
    started: Optional[int] = Field(
        None,
        description='Participants who have answered at least one question or jumped to another page. \nNote this also includes participants who have a state of "finished".\n',
    )
    finished: Optional[int] = Field(
        None, description="Participants who have completed the poll.\n"
    )


class TimeSpent(BaseModel):
    mean: Optional[float] = None
    dev: Optional[float] = None
    var: Optional[float] = None
    min: Optional[float] = None
    max: Optional[float] = None
    sum: Optional[float] = None


class Page(BaseModel):
    id: Optional[int] = None
    seen: Optional[int] = None
    dropouts: Optional[int] = Field(
        None,
        description='Participants who have a state of "started" but did not reach the last page.\n',
    )
    timeSpent: Optional[TimeSpent] = Field(
        None,
        description="Aggregated time spent by participants on the poll.\n",
        title="TimeSpent Statistics",
    )


class Question(BaseModel):
    id: Optional[int] = None
    pageId: Optional[int] = None
    answered: Optional[int] = None


class UserDevice(BaseModel):
    cnt: Optional[int] = None
    deviceType: Optional[str] = None
    os: Optional[str] = None
    browser: Optional[str] = None


class Statistics(BaseModel):
    startDate: AwareDatetime
    endDate: AwareDatetime
    participants: Participants2 = Field(
        ...,
        description="The number of participants that have seen, started and finished the poll",
        title="Participant Statistics",
    )
    timeSpent: TimeSpent = Field(
        ...,
        description="Aggregated time spent by participants on the poll.\n",
        title="TimeSpent Statistics",
    )
    pages: Optional[list[Page]] = None
    questions: Optional[list[Question]] = None
    userDevices: Optional[list[UserDevice]] = None
